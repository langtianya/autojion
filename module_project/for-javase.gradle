// In this section you declare the dependencies for your production and test code
dependencies {
 // The production code uses the...at compile time
 //依赖项目根目录libs目录的所有jar包
    compile fileTree(dir: rootProject.projectDir.absolutePath + '/libs', include: '**/*.jar')
	
	  // Declare the dependency for your favourite test framework you want to use in your tests.
    //testCompile 'junit:junit:4.12'
}

//打jar包
jar {
//manifest信息
    manifest {
        attributes("Implementation-Title": "Gradle",
	            	"Company" : "wangzhe",
                   "Implementation-Version": rootProject.sysVersion,                 
                   "JarVersion" : "v" + rootProject.dtVersion)
    }
	//输出地址
    destinationDir = rootProject.buildDistDir
}

//仅仅进行java代码打jar包，依赖classes任务
task sourcesJar(type: Jar, dependsOn: classes) {
//分类器为源代码
    classifier = 'sources'
	//从java源代码集那里获取main的所有源代码
    from sourceSets.main.allSource
    destinationDir = rootProject.buildDistDir
}

//依赖sourcesJar任务
jar.dependsOn sourcesJar

//javadoc生成可见性等级
javadoc.options.memberLevel = JavadocMemberLevel.PRIVATE

//仅仅在项目中存在generateJavadoc并且值为true才生成javadoc
javadoc.onlyIf { project.hasProperty('generateJavadoc') && project.property('generateJavadoc') == 'true'}

//进行java代码+javadoc打jar包，依赖javadoc任务
task javadocZip(type: Jar, dependsOn: javadoc) {
    classifier = "javadoc"
    from tasks["javadoc"]
    destinationDir = rootProject.buildDistDir
}
/仅仅在项目中存在generateJavadoc并且值为true才生成javadoc
javadocZip.onlyIf { project.hasProperty('generateJavadoc') && project.property('generateJavadoc') == 'true'}

//生成eclipse项目文件
eclipse {
//在每个项目的.project文件生成linkedResources，把项目自己输出到指定目录
   project {
   //名字，类型，路径（webapp项目绝对路径+...）
       linkedResource name : 'pc', type: '2', location : (project(rsOutputWebapp).projectDir.absolutePath + "/src/main/webapp/pc")
       linkedResource name : 'mobile', type: '2', location : (project(rsOutputWebapp).projectDir.absolutePath + "/src/main/webapp/mobile")
   }     
//在每个项目的.classpath文件
   classpath {
       defaultOutputDir = file(buildDir.name + "/classes/main")
	   查找.classpath文件，把指定源文件的编译文件输出到指定目录
       file {
          withXml {
		  //遍历所有节点
            def node = it.asNode()
			//
            def entryTmp = node.classpathentry.find{it.@kind =="src" && it.@path == "src/main/java"}
            if (null != entryTmp){
                entryTmp.attributes()['output'] = buildDir.name + '/classes/main';
            }
            entryTmp = node.classpathentry.find{it.@kind =="src" && it.@path == "src/test/java"}
            if (null != entryTmp){
                entryTmp.attributes()['output'] = buildDir.name + '/classes/test';
            }
            entryTmp = node.classpathentry.find{it.@kind =="src" && it.@path == "src/main/resources"}
            if (null != entryTmp){
                entryTmp.attributes()['output'] = buildDir.name + '/resources/main';
            }
            entryTmp = node.classpathentry.find{it.@kind =="src" && it.@path == "src/test/resources"}
            if (null != entryTmp){
                entryTmp.attributes()['output'] = buildDir.name + '/resources/test';
            }
			
			//把pc资源文件另外输出
            def tree = files {file(projectDir.absolutePath + '/src/main/resources/META-INF/resources/pc').listFiles()}
            def exclude = ""
            def idx = 2
            tree.each {File file ->
                node.children().add(idx++, new Node(null, "classpathentry", [kind:'src', path:'src/main/resources/META-INF/resources/pc/' + file.name, output : 'pc/' + file.name]))
                if (exclude != '') {
                    exclude += "|"
                }
				//排除的部分
                exclude += ("META-INF/resources/pc/" + file.name + "/").replaceAll('\\.', '/') + "|META-INF/resources/pc/" + file.name + "/"
            }
			//把mobile资源文件另外输出
            tree = files {file(projectDir.absolutePath + '/src/main/resources/META-INF/resources/mobile').listFiles()}
            tree.each {File file ->
                node.children().add(idx++, new Node(null, "classpathentry", [kind:'src', path:'src/main/resources/META-INF/resources/mobile/' + file.name, output : 'mobile/' + file.name]))
                if (exclude != '') {
                    exclude += "|"
                }
				//排除的部分
                exclude += ("META-INF/resources/mobile/" + file.name + "/").replaceAll('\\.', '/') + "|META-INF/resources/mobile/" + file.name + "/"
            }
			
			//把排除部分加入到path为src/main/resources，kind为src的节点。总结开来就是某某目录一部分输出到一个目标a，而另一部分需要独立输出到b，两种
			//不重复输出
            if (exclude != ''){
                node.classpathentry.find{it.@kind =="src" && it.@path == "src/main/resources"}.attributes()['excluding'] = exclude
            }
          }
       }
   }
}

